#!/usr/bin/env python2# -*- coding: utf-8 -*-"""Edited by Robert Irvin on 04-11-2018for compatibility with h5 files inscratch/AMISR_Work/spectra_Dregion"""import osimport reimport mathfrom datetime import datetime, timedeltaimport numpy as npimport tablesimport matplotlib.pyplot as pltimport globclass DregionSpectra(object):    def __init__(self,filelist):        # Input checking        if not len(filelist):            raise Exception('File list is empty.')        # this method returns list of files        self.filelist = filelist                # read times from the files        self.__catalog_data()        # initialize file handling variables        self.__loaded_file = None        self.__loaded_spectra = None        self.__loaded_range = None        self.__loaded_altitude = None        self.__loaded_frequency = None        self.__loaded_time = None        self.__loaded_beamcodes = None        self.__loaded_beamcodemap = None    def get_beamcodes(self,requested_time):        # calls and runs .__load_file here which returns None if time is not contained in files        if self.__load_file(requested_time) is None:            return None        return self.__loaded_beamcodes        def get_altitude(self,requested_time):        if self.__load_file(requested_time) is None:            return None        return (self.__loaded_altitude)    def get_range(self,requested_time):        if self.__load_file(requested_time) is None:            return None        return np.squeeze(self.__loaded_range)    def get_frequency(self,requested_time):        if self.__load_file(requested_time) is None:            return None        return np.squeeze(self.__loaded_frequency)    def get_spectrum(self,requested_time):        if self.__load_file(requested_time) is None:            return None                time_ind = np.where((self.__loaded_time[:,0] <= requested_time) & (self.__loaded_time[:,1] >= requested_time))[0]        return np.squeeze(self.__loaded_spectra[time_ind,:,:,:])    def get_spectra(self,start_time,end_time):        # figure out how many time records we have to get        # the logic on the next line is correct, even though it seems confusing at first        # The start time needs to be checked against the end times of each time record        # and the end time needs to be checked against the start times of each record.        request_time_inds = np.where((self.times[:,0] <= end_time) & (self.times[:,1] >= start_time))[0]        temp_times = self.times[request_time_inds]        if len(temp_times) < 1:            print("No data for request start and end times.")            return None        request_times = list()        epoch = datetime(1970,1,1)        for tup in temp_times:            t1 = (tup[0] - epoch).total_seconds()            t2 = (tup[1] - epoch).total_seconds()            request_times.append(datetime.utcfromtimestamp((t1+t2)/2.0))        request_times.sort()        num_times = len(request_times)        beamcodes = self.get_beamcodes(request_times[0])        num_beams = beamcodes.shape[0]        # changing num_freqs to be equal to the frequency dimension of a spectrum        num_freqs = self.get_spectrum(request_times[0]).shape[1]        #        num_gates = self.__loaded_range.shape[-1]        spectra = np.zeros((num_times,num_beams,num_freqs,num_gates))        for i,time in enumerate(request_times):            temp = self.get_spectrum(time)            spectra[i,:,:,:] = temp        return spectra, temp_times    def get_noise_sub_spectra(self,start_time,end_time):        spectra , times = self.get_spectra(start_time,end_time)# spectra array is 4D (times, beams, frequency, altitude) # first we need to noise subtract the spectra, to do this we integrate# the spectra over 'dark altitudes', which are in the 50-60 km range.# Should we make this a global class variable? Or allow this to be set by the user # otherwise?   # noise region will be at a different index for each beam so first itearate# through beams        dark_alts = (52.5,57.5) # bounds on the dark altitudes in kilometers        num_beams = self.__loaded_beamcodes.shape[0]        alt_km = self.__loaded_altitude/1000                # tuple of indexes of the dark altitudes for each beam        idxs = (np.abs(alt_km-dark_alts[0]).argmin(axis=1),                np.abs(alt_km-dark_alts[1]).argmin(axis=1))        # initialize time dependent noise variable and the noise subtracted spectra        spectra_subnoise = np.copy(spectra)        tdn = np.zeros((times.shape[0],num_beams))        for ind_beam in range(num_beams):            tdn[:,ind_beam] = np.median(np.median(spectra[:,ind_beam,:,                idxs[0][ind_beam]:idxs[1][ind_beam]],axis=2),axis=1)            spectra_subnoise[:,ind_beam,:,:] -= tdn[:,ind_beam,np.newaxis,np.newaxis]                     return spectra_subnoise , times, tdn                       def get_moments(self,spectra):        if len(spectra.shape) != 4:            raise Exception('Spectra must have dimension 4 (time, beam, frequency, altitude)')        zero_moment = np.sum(spectra, axis = 2) #(time,beam,altitude)        # need to create a frequency aray the same dimension as the        # spectra frequency axis                #first check if frequency array has same dimension as axis        if self.__loaded_frequency.shape[0] == spectra.shape[2]:            freq = self.__loaded_frequency        else:       # assume dimension of frequency array is 1 greater            freq = np.zeros(spectra.shape[2])            for i in range(freq.shape[0]):                freq[i] = (self.__loaded_frequency[i]+self.__loaded_frequency[i+1])/2                        first_moment = np.sum(spectra*freq[:,np.newaxis],axis=2)/(zero_moment) #(time,beam,alt)        fm = np.expand_dims(first_moment,axis=2) ;  ffm = np.repeat(fm, freq.shape[0],axis=2)                second_moment = np.sum((freq[:,np.newaxis] - ffm)**2 * spectra ,axis=2)/(zero_moment)                return zero_moment, first_moment, second_moment        def __load_file(self,requested_time):        time_ind = np.where((self.times[:,0] <= requested_time) & (self.times[:,1] >= requested_time))[0]        if len(time_ind) < 1:            print("Requested time not found.")            return None        # If it is, let's see if we have that file loaded or not        needed_file = self.filetimes[tuple(self.times[time_ind[0]])]        if self.__loaded_file != needed_file:            print("Loading file: %s" % needed_file)            # Load the arrays in Data/Spectra and the Time/UnixTime data            with tables.open_file(needed_file,'r') as h5:                #node = h5.get_node(self.plasmaline_mode)                self.__loaded_beamcodes = h5.root.BeamCodes.read()                self.__loaded_spectra = h5.root.Processed.Spectra.read()                self.__loaded_range =  h5.root.Processed.Range.read()                self.__loaded_altitude = h5.root.Processed.Altitude.read()                temp_frequency = h5.root.Processed.Frequency.read()                  temp_time = h5.root.Time.UnixTime.read()            # determine the frequencies for the plasma line spectra            self.__loaded_frequency = temp_frequency             # Convert UnixTime to datetime            num_times = temp_time.shape[0]            temp = list()            for i in range(num_times):                time_pair = [datetime.utcfromtimestamp(temp_time[i,0]),                             datetime.utcfromtimestamp(temp_time[i,1])]                temp.append(time_pair)            self.__loaded_time = np.array(temp)            self.__loaded_file = needed_file        return True    def __catalog_data(self):        # for each file in self.filelist, grab all the times and make a dictionary mapping to that file for each datetime        self.filetimes = dict()        # For every file that we have, grab the start and end times in the files.        # We need to check every time, in case there is a gap in the file.        for fname in self.filelist:            with tables.open_file(fname,'r') as h5:                temp_times = h5.root.Time.UnixTime.read()            num_times = temp_times.shape[0]            for i in range(num_times):                file_time = (datetime.utcfromtimestamp(temp_times[i,0]),                             datetime.utcfromtimestamp(temp_times[i,1])                            )                self.filetimes[file_time] = fname        # now get an array of start and ends times from the keys of the filetimes dict        temp = [list(x) for x in self.filetimes.keys()]        temp.sort()        self.times = np.array(temp)    def nan_the_zeros(self , array):        I = np.where(array < 0)        array[I] = np.nan        masked_array = np.ma.masked_where(np.isnan(array),array)                return masked_array        def plot_spectra(self,start_time,end_time):        integration_time = timedelta(minutes=5) # time to integrate spectra in minutes        resolution_time  = timedelta(minutes = 30)        req_time = start_time          # initialize requested time to start time                while req_time + integration_time < end_time: # evaluates to false if time is out of range            if req_time == start_time:                self.__load_file(req_time +integration_time)                # initialize alt, beams, etc. read in spectra                num_beams = self.__loaded_beamcodes.shape[0]            alt_km    = self.__loaded_altitude/1000            Freq = self.__loaded_frequency            spectra , times = self.get_spectra(req_time,req_time+integration_time)            noise_sub_spectra, tdn , times = self.get_noise_sub_spectra(req_time,req_time+integration_time)            zm, fm, sm          = self.get_moments(spectra)            zm_ns, fm_ns, sm_ns = self.get_moments(noise_sub_spectra)            # initialize figure and subcolumn ratios            gridspec_kw = dict(width_ratios = num_beams*(0.5,0.03,0.25,0.045) )            fig,axes = plt.subplots(nrows=2,ncols=4*num_beams,sharey='row',                                    figsize = (16,8),                                    gridspec_kw=gridspec_kw)                                    # nan the values of power and spectral width that are below zero                        sm_array = self.nan_the_zeros(sm)            sm = np.sqrt(sm_array)                        power_array = self.nan_the_zeros(zm)                         sm_ns_array = self.nan_the_zeros(sm_ns)            sm_ns       = np.sqrt(sm_ns_array)                        for ind_beam in range(num_beams): # ax[0] is first col, ax[1] is second                if ind_beam == 0:                    axes[0,ind_beam].set_title('raw spectra');axes[1,ind_beam].set_title('noise subtract spectra')                x,y        = np.meshgrid(Freq,alt_km[ind_beam])                s0,s1      = np.median(spectra[:,ind_beam],axis=0),np.median(noise_sub_spectra[:,ind_beam],axis=0)                mm0,mm1    = np.median(s0), np.median(s1)                std0,std1  = np.std(s0) , np.std(s1)                                im0        = axes[0,num_beams*ind_beam].pcolormesh(x,y,s0.T,vmin = mm0-0.75*std0,vmax = mm0+2*std0,cmap='bone_r')                cb0        = fig.colorbar(im0 , ax = axes[0,num_beams*ind_beam])                                                im1        = axes[1,num_beams*ind_beam].pcolormesh(x,y,s1.T,vmin = mm1-0.75*std1,vmax = mm1+2*std1,cmap='bone_r')                cb1        = fig.colorbar(im1 , ax = axes[1,num_beams*ind_beam])                                axes[0,num_beams*ind_beam+2].plot( np.median(sm[:,ind_beam],axis=0)/2 , alt_km[ind_beam])                axes[1,num_beams*ind_beam+2].plot( np.median(sm_ns[:,ind_beam],axis=0)/2 , alt_km[ind_beam])                                                axes[0,num_beams*ind_beam+1].remove()                axes[0,num_beams*ind_beam+3].remove()                axes[1,num_beams*ind_beam+1].remove()                axes[1,num_beams*ind_beam+3].remove()            fig.suptitle(req_time.strftime('%Y/%m/%d %H:%M')+' to '+ (req_time+integration_time).strftime('%H:%M UT'))            plt.show(fig)                        req_time += resolution_timebasepath = '/Users/E31345/Desktop'files =glob.glob(os.path.join(basepath,'20170508.001/datfiles/*.h5'))dreg = DregionSpectra(files) """import requestsfrom collections import OrderedDicturl = 'http://wdc.kugi.kyoto-u.ac.jp/cgi-bin/kp-cgi'data = OrderedDict()data['SCent'] = 20data['STens'] = 1data['SYear'] = 2data['From'] = 3data['ECent'] = 20data['ETens'] = 1data['EYear'] = 2data['To'] = 4data['Email'] = 'robert.irvin@sri.com'r = requests.post(url,data=data)print(r.text)from bs4 import BeautifulSoupsoup = BeautifulSoup(r.text,'html.parser')soup.pre.contents[0].split('\n')   """    